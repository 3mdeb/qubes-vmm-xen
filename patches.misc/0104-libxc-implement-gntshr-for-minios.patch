From 70c2eedd133e2d72ee7e9c32dcf12d304006ca73 Mon Sep 17 00:00:00 2001
From: Marek Marczykowski <marmarek@invisiblethingslab.com>
Date: Tue, 23 Apr 2013 05:17:59 +0200
Subject: [PATCH 104/106] libxc: implement gntshr for minios
Organization: Invisible Things Lab
Cc: Marek Marczykowski <marmarek@invisiblethingslab.com>

Signed-off-by: Marek Marczykowski <marmarek@invisiblethingslab.com>
---
 tools/libxc/xc_minios.c | 71 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 71 insertions(+)

diff --git a/tools/libxc/xc_minios.c b/tools/libxc/xc_minios.c
index dec4d73..eeaf966 100644
--- a/tools/libxc/xc_minios.c
+++ b/tools/libxc/xc_minios.c
@@ -26,6 +26,7 @@
 #include <mini-os/mm.h>
 #include <mini-os/lib.h>
 #include <mini-os/gntmap.h>
+#include <mini-os/gnttab.h>
 #include <mini-os/events.h>
 #include <mini-os/wait.h>
 #include <sys/mman.h>
@@ -519,6 +520,74 @@ static struct xc_osdep_ops minios_gnttab_ops = {
     },
 };
 
+static xc_osdep_handle minios_gntshr_open(xc_gntshr *xcg)
+{
+    return (xc_osdep_handle)0;
+}
+
+static int minios_gntshr_close(xc_gntshr *xcg, xc_osdep_handle h)
+{
+    return 0;
+}
+
+static void *minios_gntshr_share_pages(xc_gntshr *xch, xc_osdep_handle h,
+                                      uint32_t domid, int count,
+                                      uint32_t *refs, int writable,
+                                      uint32_t notify_offset,
+                                      evtchn_port_t notify_port)
+{
+    int i, mfn;
+    void *area = NULL;
+
+    if (notify_offset != -1 || notify_port != -1) {
+        printf("minios_gntshr_share_pages: notify not implemented\n");
+        errno = ENOSYS;
+        return NULL;
+    }
+
+    area = memalign(XC_PAGE_SIZE, count * XC_PAGE_SIZE);
+
+    if (!area) {
+        PERROR("minios_gntshr_share_pages: alloc failed");
+        return NULL;
+    }
+
+    for (i = 0; i < count; i++) {
+        mfn = virtual_to_mfn(area + i*XC_PAGE_SIZE);
+        refs[i] = gnttab_grant_access(domid, mfn, !writable);
+    }
+
+    return area;
+}
+
+static int minios_gntshr_munmap(xc_gntshr *xcg, xc_osdep_handle h,
+                               void *start_address, uint32_t count)
+{
+    int i;
+    uint32_t gref;
+
+    for (i = 0; i < count; i++) {
+        gref = gnttab_find_grant_of_page(start_address + i * PAGE_SIZE);
+        if (!gref) {
+            errno = EINVAL;
+            return -1;
+        }
+        gnttab_end_access(gref);
+    }
+
+    return 0;
+}
+
+static struct xc_osdep_ops minios_gntshr_ops = {
+    .open = &minios_gntshr_open,
+    .close = &minios_gntshr_close,
+
+    .u.gntshr = {
+        .share_pages = &minios_gntshr_share_pages,
+        .munmap = &minios_gntshr_munmap,
+    },
+};
+
 static struct xc_osdep_ops *minios_osdep_init(xc_interface *xch, enum xc_osdep_type type)
 {
     switch ( type )
@@ -529,6 +598,8 @@ static struct xc_osdep_ops *minios_osdep_init(xc_interface *xch, enum xc_osdep_t
         return &minios_evtchn_ops;
     case XC_OSDEP_GNTTAB:
         return &minios_gnttab_ops;
+    case XC_OSDEP_GNTSHR:
+        return &minios_gntshr_ops;
     default:
         return NULL;
     }
-- 
1.8.1.4

